HIBERNATE
---------

ORM (Object Relation Mapping)
Implements JPA
Use data layer application

ORM
Persist data in the database table
Class --> Table
Attributes ---> table column

Problem in JDBC
Map member variable to columns
Mapping relationships - Foreign key and primary key
Handling Data Types 
Managing changes to object state

In HIBERNATE

*JDBC database configuration - Hibernate configuration (to tell abt database) using hivernate configuration file
*Model object - Annotation (what needs to be saved and how)
*Service method to create model object -service method directly calls hibernate api which saves of model obj
*Database design - not needed
*DAO to convert the obj in the realation model like sql queries - Not needed

hibernate.cfg.xml - this is the default configuration file name if we change the name we need to pass to the hibernate the file name

Postgres correction url 
jdbc:postgresql://<host>:<port>/<DB>

hibernate.dialect : So that hibernate knows what language is need to talk to the database

show_sql: Print the sql generated

hibernate.hbm2ddl.auto: hibernate creates the table 
*create-drop : it creates the schema everytime
*update: It only makes the change if it finds the change or else update the same
<mapping class="org.shubham.dto.UserDetails"/> // Model class that needs to be persisted in the database

@Entity from javax.persistence // Treat the class as Entity for the database table

Hibernate API

* Session Factory
* Session form the session factory
* Use the session from model objects

SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
Session session = sessionFactory.openSession();
session.beginTransaction();
session.save(user);
session.getTransaction().commit();

@Id
@Column(name="USER_ID") // to give name to the column attribute in the table

@Entity
@Table(name="USER_DETAILS") // Entity name is the same just the table name has changed

@Basic // to treat something wch needs to be persisted in the database
@Transient // If you want to ignore the field from being inserted in the database
@Temporal(TemporalType.DATE) // Just to save the date not the timestamp
@Lob // it is large object if in front of String then it takes it as CLOB character large object 

// to fetch data from the database
user = (UserDetails)session.get(UserDetails.class, 3); // 3 is the id wch we are trying to fetch

@GeneratedValue(strategy=GenerationType.AUTO) // For auto generation of value

Entity n Value object 
Value obj - It doesnot have the value of itself it provides the value to something else like address obj
Entity - Has value of its own


@Embeddable // to mark it value obj not as seperate entity
@Embedded // Object is embedded 
	@AttributeOverrides({  // to have multiple overrides
	@AttributeOverride(name="street",column=@Column(name="HOME_STREET_NAME")),
	@AttributeOverride(name="street",column=@Column(name="HOME_CITY_NAME")),
	@AttributeOverride(name="street",column=@Column(name="HOME_STATE_NAME")),
	@AttributeOverride(name="street",column=@Column(name="HOME_PIN_CODE"))
	})
	
@EmbeddedId // all the combination is treated as the primary key
@ElementCollection // To treat it as the collection, it creates a seperate not is embedded in the same table
@JoinTable(name="USER_ADDRESS") // TO tweak the name in the collection
// To change the name of the autogenerated value inside the collection table
@JoinTable(name="USER_ADDRESS", 
			   joinColumns=@JoinColumn(name="USER_ID")
			)

			
// Use array list as we require primary key in the collection
private Collection<Address> listofAddress = new ArrayList<Address>();

* All are hibernate ones not the javax
//For auto generation of id
@GenericGenerator(name = "increment-gen", strategy = "increment") 
// To generate the primary key in the collection 
@CollectionId(columns = { @Column(name="ADDRESS_ID") }, generator = "increment-gen", type = @Type(type="long"))

//this will not pull the address list of the collection
 
		user = (UserDetails) session.get(UserDetails.class, 1);

//Lazy initialization we get the value of list only if we want it
//Hibernate gets you the proxy class which fills the first level of details leaving the list of address 
	user.getListofAddress();
		
		
// Eager initialization to get the value in the first time itself
@ElementCollection(fetch=FetchType.EAGER)

One to One
-----------
Relationship between tables
Other table is not the embeddable object 
@OneToOne // use to map one table to another. One table has the primary key of another table

Many to One
------------
We can insert more than one obj of the other table
@OneToMany
Hibernate: insert into USER_DETAIL_OTM (userName, Id) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into USER_DETAIL_OTM_Vehicle (UserDetails_Id, vehicle_vehicleId) values (?, ?)
Hibernate: insert into USER_DETAIL_OTM_Vehicle (UserDetails_Id, vehicle_vehicleId) values (?, ?)

USER_DETAIL_OTM_Vehicle table will have mapping to both the vehicles

@OneToMany
@JoinTable(name="USER_VEHICLE", joinColumns=@JoinColumn(name="USER_ID"),
			inverseJoinColumns=@JoinColumn(name="VEHICLE_ID")
		)
		
name // this changes the name of USER_DETAIL_OTM_Vehicle table
inverseJoinColumns // refers to the other table which is mapped in the many relatioship

Hibernate: insert into USER_DETAIL_OTM (userName, Id) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into USER_VEHICLE (USER_ID, VEHICLE_ID) values (?, ?)
Hibernate: insert into USER_VEHICLE (USER_ID, VEHICLE_ID) values (?, ?)

Many vehicle can have one user
so we make the mapping on the vehicle side remove it from user table side
// In order to remove the USER_VEHICLE table as a seperate table
// On the user table side
// We will make the user id and vehicle id mapping on the vehicle table itself
// user refers to the object on the vehicle table side 
	@OneToMany(mappedBy="user")

// On the Vehicle table side
	@JoinColumn(name="USER_ID")
	private UserDetails user;
	
Hibernate: insert into USER_DETAIL_OTM (userName, Id) values (?, ?)
Hibernate: insert into Vehicle (USER_ID, vehicleName, vehicleId) values (?, ?, ?)
Hibernate: insert into Vehicle (USER_ID, vehicleName, vehicleId) values (?, ?, ?)


	
Many to Many
-------------
Bidirectional relationships

@ManyToMany
// It creates two mapping

Hibernate: insert into USER_DETAIL_MTM (userName, Id) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into USER_DETAIL_MTM_Vehicle (UserDetails_Id, vehicle_vehicleId) values (?, ?)
Hibernate: insert into USER_DETAIL_MTM_Vehicle (UserDetails_Id, vehicle_vehicleId) values (?, ?)
Hibernate: insert into Vehicle_USER_DETAIL_MTM (Vehicle_vehicleId, user_Id) values (?, ?)
Hibernate: insert into Vehicle_USER_DETAIL_MTM (Vehicle_vehicleId, user_Id) values (?, ?)

// To have one table mapping in Vehicle class

	@ManyToMany(mappedBy="vehicle")
	private Collection<UserDetails> user = new ArrayList<>();
	
Hibernate: insert into USER_DETAIL_MTM (userName, Id) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into USER_DETAIL_MTM_Vehicle (user_Id, vehicle_vehicleId) values (?, ?)
Hibernate: insert into USER_DETAIL_MTM_Vehicle (user_Id, vehicle_vehicleId) values (?, ?)

	@ManyToMany
	@JoinTable(name="USER_VEHICLE", joinColumns=@JoinColumn(name="USER_ID"),
	inverseJoinColumns=@JoinColumn(name="VEHICLE_ID")
			)
	private Collection<Vehicle> vehicle = new ArrayList<Vehicle>();
	
Hibernate: insert into USER_DETAIL_MTM (userName, Id) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into Vehicle (vehicleName, vehicleId) values (?, ?)
Hibernate: insert into USER_VEHICLE (USER_ID, VEHICLE_ID) values (?, ?)
Hibernate: insert into USER_VEHICLE (USER_ID, VEHICLE_ID) values (?, ?)


	@ManyToOne
//  If the user is not found during the get user then ignore the exception
	@NotFound(action=NotFoundAction.IGNORE)
//  To have the same user and vehicle id mapping on the same table
	@JoinColumn(name="USER_ID")
	private UserDetails user;

// For saving the 10 users CASCADE
// So when you want to save the multiple value of vehicle then in user details where we have the reference of the vehicle we will make it cascade so that it saves them automatically

	@ManyToMany(cascade=CascadeType.PERSIST)
	@JoinTable(name="USER_VEHICLE", joinColumns=@JoinColumn(name="USER_ID"),
	inverseJoinColumns=@JoinColumn(name="VEHICLE_ID")
			)
	private Collection<Vehicle> vehicle = new ArrayList<Vehicle>();
	

Inheritance
-----------
Vehicle class for 2 wheeler and 4 wheeler
Hibernate creates one table for all column no matter what inheritance you have

Hibernate: insert into Vehicle (vehicleName, DTYPE, vehicleId) values (?, 'Vehicle', ?)
Hibernate: insert into Vehicle (vehicleName, SteeringHandle, DTYPE, vehicleId) values (?, ?, 'TwoWheeler', ?)
Hibernate: insert into Vehicle (vehicleName, SteeringWheel, DTYPE, vehicleId) values (?, ?, 'FourWheeler', ?)

DTYPE - tells what class it is 

// Single table means all will be in the single table
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
// to change the DTYPE name
@DiscriminatorColumn(name="VEHICLE_TYPE",
					 discriminatorType=DiscriminatorType.STRING
		)

// To have inheritance in separate table
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)

// To have the joined type inheritance
// data created for parent table remins in the parent table it doesnot goes to the child table
// We can do the join on parent table based on the vehicleId to get all the required data
// All the properties inherited from the parent class is not copied to child class it remains in parent
@Inheritance(strategy=InheritanceType.JOINED)